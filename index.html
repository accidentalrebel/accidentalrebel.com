<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AccidentalRebel.com</title>
    
    <link href="https://www.accidentalrebel.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="AccidentalRebel.com Atom Feed" />
    
    <link rel="stylesheet" href="./theme/css/main.css">
    
</head>
<body>
    <div class="progress-bar" id="progress"></div>
    
    <header>
        <div class="container">
            <nav>
                <a href="./" class="site-title">AccidentalRebel.com</a>
                <button class="menu-toggle" onclick="toggleMenu()">☰</button>
                <ul class="nav-links" id="navLinks">
                    <li><a href="./archives.html">Archives</a></li>
                    <li><a href="./categories.html">Categories</a></li>
                    <li><a href="./tags.html">Tags</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Comic strip divider -->
    <div class="comic-container">
        <div class="comic-strip"></div>
    </div>

    <main>
        <div class="container">
    <article class="post-item">
        <header class="article-header">
            <h2 class="post-title">
                <a href="./building-a-session-retrospective-skill-for-claude-code.html">Building a session retrospective skill for Claude Code</a>
            </h2>
            <div class="article-meta">
                <time datetime="2026-02-01T12:00:00+08:00">Sun 01 February 2026</time>
                <span>•</span>
                <a href="./category/programming.html">programming</a>
            </div>
        </header>

        <div class="article-content">
            <p>I've been using Claude Code for a while now, and I noticed a pattern: at the end of a productive session, I'd have this vague sense of "we figured out some useful stuff" but no concrete record of what those lessons actually were.</p>
<p>Recently, I learned of a skill called <a href="https://github.com/affaan-m/everything-claude-code/tree/main/skills/continuous-learning">continuous-learning</a>. It automatically extracts reusable patterns and saves them as skills. But I wanted something different. Not automated pattern extraction, but a human-readable summary I could actually share. Something I could look back on, or turn into a blog post.</p>
<p>So I built the <a href="https://github.com/accidentalrebel/claude-skill-session-retrospective">session-retrospective</a> skill.</p>
<h2 id="what-it-does">What it does</h2>
<p>The skill analyzes the current Claude session and generates a markdown summary covering:</p>
<ul>
<li>What we set out to do</li>
<li>Problems encountered and how they were solved</li>
<li>Mistakes made and corrections</li>
<li>Techniques discovered worth remembering</li>
<li>Key takeaways</li>
</ul>
<p>The output goes straight to console for copy/paste. No files created, no cleanup needed.</p>
<h2 id="how-it-works">How it works</h2>
<p>Claude Code stores session history as JSONL files in <code>~/.claude/projects/&lt;project-dir&gt;/&lt;session-id&gt;.jsonl</code>. Each line is JSON with message type, content, timestamps, and metadata. A simple bash file locates and outputs the session JSONL:</p>
<div class="codehilite"><pre><span></span><code><span class="nv">SESSION_FILE</span><span class="o">=</span><span class="k">$(</span>find<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$PROJECTS_DIR</span><span class="s2">&quot;</span><span class="w"> </span>-name<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">SESSION_ID</span><span class="si">}</span><span class="s2">.jsonl&quot;</span><span class="w"> </span>-type<span class="w"> </span>f<span class="w"> </span><span class="p">|</span><span class="w"> </span>head<span class="w"> </span>-1<span class="k">)</span>
cat<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$SESSION_FILE</span><span class="s2">&quot;</span>
</code></pre></div>

<p>Once the history is fetched, the actual analysis is left to Claude with structured guidance. I provided a template for the output format and a table of what to look for (problems, decisions, techniques, mistakes). There's a lot of freedom, since synthesizing lessons requires judgment.</p>
<h2 id="whats-next">What's next</h2>
<p>The skill works for my current needs. I haven't tested it extensively on very long sessions (the JSONL can get large and might need chunking). For now, it handles my typical single-session bursts fine.</p>
<p>Also, the output format might need iteration based on actual use. The template includes sections for "mistakes made" and "techniques worth remembering" but maybe other categories would be more useful. I'll adjust as I use it more.</p>
<p>The code is <a href="https://github.com/accidentalrebel/claude-skill-session-retrospective">here</a> if you want to try it.</p>
        </div>

        <div class="tags">
            <a href="./tag/claude-code.html" class="tag">claude-code</a>
            <a href="./tag/tools.html" class="tag">tools</a>
            <a href="./tag/ai.html" class="tag">ai</a>
            <span class="tag">+1 more</span>
        </div>
    </article>
    <article class="post-item">
        <header class="article-header">
            <h2 class="post-title">
                <a href="./running-ai-agents-in-a-box.html">Running AI agents in a box because I don't trust them</a>
            </h2>
            <div class="article-meta">
                <time datetime="2026-01-30T10:00:00+08:00">Fri 30 January 2026</time>
                <span>•</span>
                <a href="./category/programming.html">programming</a>
            </div>
        </header>

        <div class="article-content">
            <p>I built a Docker wrapper for Claude Code and OpenAI Codex. The main reason is simple: I don't trust AI agents running loose on my machine.</p>
<p>Being in Cyber Security, I've developed a healthy paranoia about software that can execute arbitrary commands. AI coding assistants are powerful, but they're also unpredictable. They can run shell commands, modify files, and access the network. I wanted all of that contained.</p>
<h2 id="the-setup">The setup</h2>
<p>Claudecker is my personal tool that wraps Docker to run Claude Code CLI and Codex CLI in an isolated container. Point it at any project directory and it mounts that directory into the container. The AI can do whatever it wants inside the container, but it can't touch the rest of my system.</p>
<div class="codehilite"><pre><span></span><code>./claudecker.sh<span class="w"> </span>run<span class="w"> </span>/path/to/project
</code></pre></div>

<p>Each run starts with a fresh environment. Skills get reinstalled, settings reset to defaults. Only authentication tokens persist across restarts. This "clean slate" approach means I don't accumulate cruft or unexpected state changes.</p>
<h2 id="the-paranoid-feature-network-lockdown">The paranoid feature: network lockdown</h2>
<p>The feature I'm most pleased with is the network lockdown toggle. It uses iptables to control the container's OUTPUT chain policy.</p>
<div class="codehilite"><pre><span></span><code>./claudecker.sh<span class="w"> </span>lockdown
</code></pre></div>

<p>This drops all outbound traffic except localhost and already-established connections. The AI can still work on code, but it can't phone home, download packages, or exfiltrate anything. I toggle this on when working on sensitive projects.</p>
<p>The implementation is straightforward. Just flipping between DROP and ACCEPT policies. The container needs NET_ADMIN capability for this to work, which is a trade-off I'm comfortable with since it's scoped to network operations.</p>
<h2 id="trade-offs-from-containerization">Trade-offs from containerization</h2>
<p>Isolation comes with friction. I had to solve several problems that wouldn't exist if I just ran the CLI directly on my host.</p>
<h3 id="browser-authentication-needs-x11">Browser authentication needs X11</h3>
<p>Claude and Codex authentication use browser-based OAuth flows. Inside a container, there's no browser. I ended up mounting the X11 socket and forwarding the DISPLAY variable:</p>
<div class="codehilite"><pre><span></span><code><span class="nt">volumes</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">/tmp/.X11-unix:/tmp/.X11-unix:rw</span>
</code></pre></div>

<p>On Linux this works if you have DISPLAY set. On macOS you need XQuartz. For headless environments, there's a fallback where I manually copy the auth.json file from a machine where you've already logged in.</p>
<p>Thankfully, Claude Code and Codex CLI makes it easier by providing you a URL to visit, which will give you a code to enter back. This means I rarely need to use browser authentication, but at least the option is there.</p>
<h3 id="ssh-agent-forwarding-is-annoying">SSH agent forwarding is annoying</h3>
<p>Getting SSH keys into the container without copying them required some workarounds. Docker's socket permissions don't always cooperate, so I ended up using socat to proxy the SSH agent socket:</p>
<div class="codehilite"><pre><span></span><code>sudo<span class="w"> </span>socat<span class="w"> </span>UNIX-LISTEN:/tmp/ssh-agent-forwarded,fork,mode<span class="o">=</span><span class="m">600</span>,user<span class="o">=</span>node<span class="w"> </span><span class="se">\</span>
<span class="w">          </span>UNIX-CONNECT:/ssh-agent<span class="w"> </span><span class="p">&amp;</span>
</code></pre></div>

<p>The container tries direct socket access first, falls back to socat if that fails. Limited sudo permissions ensure the node user can only run specific commands.</p>
<h3 id="port-forwarding-for-web-apps">Port forwarding for web apps</h3>
<p>If you're developing a web app and want to access it from your host browser, you need to expose ports explicitly:</p>
<div class="codehilite"><pre><span></span><code>./claudecker.sh<span class="w"> </span>run<span class="w"> </span>--port<span class="w"> </span><span class="m">3000</span><span class="w"> </span>/path/to/project
</code></pre></div>

<p>This maps the container's port to the host. Without this flag, localhost:3000 inside the container isn't reachable from outside.</p>
<h2 id="project-specific-dependencies">Project-specific dependencies</h2>
<p>Different projects need different tools. A C project needs gcc and cmake. A Python ML project needs different libraries. I didn't want to bloat the base image with everything.</p>
<p>The solution: a <code>.claudecker</code> file in the project directory.</p>
<div class="codehilite"><pre><span></span><code># .claudecker
build-essential
cmake
gcc
python3-dev
</code></pre></div>

<p>On first run, the script hashes the file contents, generates a Dockerfile, and builds a custom image tagged with that hash. Subsequent runs use the cached image. Projects with identical <code>.claudecker</code> files share the same image.</p>
<div class="codehilite"><pre><span></span><code>claudecker-custom:a1b2c3d4e5f6
</code></pre></div>

<p>This content-based approach means I'm not rebuilding images unnecessarily, and cleanup is straightforward with <code>clean-custom</code> and <code>clean-all-custom</code> commands.</p>
<h2 id="skills-system">Skills system</h2>
<p>A new and recent addition: Claudecker now supports Claude Skills, which are custom prompts that extend its capabilities. I implemented two types:</p>
<ul>
<li>GitHub skills get cloned on container startup. The <a href="https://github.com/blader/humanizer">Humanizer skill</a>, for example, comes from a public repo and helps remove AI-isms from text.</li>
<li>Local skills are baked into the Docker image. I keep these in a <code>local-skills/</code> directory.</li>
</ul>
<p>The build process copies these into the image, and the entrypoint installs them into Claude's skills directory. This way I can version-control project-specific skills alongside the code.</p>
<h2 id="multi-ai-orchestration-with-pal-mcp">Multi-AI orchestration with PAL MCP</h2>
<p>I also integrated PAL MCP Server, which lets Claude Code collaborate with other AI models (Gemini, GPT, Grok, local Ollama models). I export my API keys before running:</p>
<div class="codehilite"><pre><span></span><code><span class="nb">export</span><span class="w"> </span><span class="nv">OPENROUTER_API_KEY</span><span class="o">=</span><span class="s2">&quot;your-key&quot;</span>
./claudecker.sh<span class="w"> </span>run<span class="w"> </span>/path/to/project
</code></pre></div>

<p>Inside Claude Code, I can ask it to use other models for second opinions, code review, or extended reasoning. The MCP server handles the routing.</p>
<p>This obviously requires network access, so it doesn't work in lockdown mode. Trade-offs.</p>
<h2 id="wheres-the-code">Where's the code?</h2>
<p>I planned to release this publicly but decided against it for now. There are rough edges:</p>
<ul>
<li>The docker-compose volumes are duplicated in the docker run command for custom images. If you change one, you have to change the other. I left a warning comment but it's still error-prone.</li>
<li>The firewall whitelist script exists but isn't fully tested across different network configurations.</li>
<li>Some features assume specific host setups (X11, SSH agent running, etc.) and fail ungracefully when those assumptions don't hold.</li>
<li>Error handling is minimal in places.</li>
</ul>
<p>I use this daily for my own work, but it's not polished enough for others to pick up without reading through the scripts first. Maybe later.</p>
<h2 id="current-limitations">Current limitations</h2>
<ul>
<li>Network lockdown state doesn't persist across container restarts. Restart the container and you're back to full network access.</li>
<li>Custom image builds happen automatically but failures silently fall back to the base image. You might not notice a package didn't install.</li>
<li>X11 forwarding is a security surface I'm not entirely comfortable with, but I haven't found a better solution for browser auth.</li>
</ul>
<h2 id="what-i-actually-use-it-for">What I actually use it for</h2>
<p>Most days I run Claude Code in lockdown mode for general coding tasks. When I need it to fetch documentation or install packages, I toggle lockdown off, let it do its thing, then toggle it back on.</p>
<p>For security research projects, the isolation gives me peace of mind. The AI can analyze suspicious code, suggest modifications, even run tests, all without access to my actual filesystem or network.</p>
<p>It's not perfect containment. Docker isn't a security boundary the way a VM is. But it's enough friction that an AI agent can't accidentally (or intentionally) do something I'd regret.</p>
<p>For now, this setup works for my needs. The paranoia tax is a few extra seconds on startup and occasional friction with browser auth. Worth it.</p>
        </div>

        <div class="tags">
            <a href="./tag/docker.html" class="tag">docker</a>
            <a href="./tag/ai.html" class="tag">ai</a>
            <a href="./tag/claude-code.html" class="tag">claude-code</a>
            <span class="tag">+2 more</span>
        </div>
    </article>
    <article class="post-item">
        <header class="article-header">
            <h2 class="post-title">
                <a href="./classifying-more-with-less-new-vgl4nt-update.html">Classifying More With Less: New VGL4NT Update</a>
            </h2>
            <div class="article-meta">
                <time datetime="2023-05-20T06:46:00+08:00">Sat 20 May 2023</time>
                <span>•</span>
                <a href="./category/misc.html">misc</a>
            </div>
        </header>

        <div class="article-content">
            <h2 id="tldr">TLDR:</h2>
<ul>
<li>Packed malware machine learning classifier can only previously identify 10 packers</li>
<li>Solution was a customized version of model ensembling, which is to train multiple models and resolve their results</li>
<li>It works with a slight caveat of more extended training and processing, which I could happily live with</li>
</ul>
<p>I recently presented <a href="https://packers.vgl4nt.com/">VGL4NT</a>, my tool that uses machine learning to classify packed malware, at the Blackhat Middle East and Africa meetup. During my talk, I candidly shared one of the tool's limitations which is it can only identify 10 packers because of my hardware constraints. If I want it to be able to identify more, I need to get more GPU (which will be costly) or keep my money and come up with a clever solution. Well, this post is about the latter.</p>
<h2 id="a-simple-solution">A Simple Solution</h2>
<p>The solution I came up with isn't exactly original. It's based on Task Decomposition, which involves training separate models for different categories and combining their predictions. This way, I could double the classification capacity without requiring additional hardware resources.</p>
<p>This was implemented by creating multiple machine learning models, each specializing in recognizing a subset of packers. The real challenge, however, lies in combining the predictions from these models to form a unified output.</p>
<p><img alt="classifying-more-with-less-new-vgl4nt-update-01" src="./images/classifying-more-with-less-new-vgl4nt-update-01.png" /></p>
<p>Here's how the process works:</p>
<p>The packed malware file is fed into Model 1, which outputs probabilities for Packer 1, Packer 2, and Others. For example, it might produce:</p>
<ul>
<li>Packer 1: 10%</li>
<li>Packer 2: 20%</li>
<li>Others: 70%</li>
</ul>
<p>The same file is then fed into Model 2, which outputs probabilities for Packer 3, Packer 4, and Others. For instance:</p>
<ul>
<li>Packer 3: 60%</li>
<li>Packer 4: 30%</li>
<li>Others: 10%</li>
</ul>
<p>I then take the 'Others' category with the lowest probability. For our example, the final 'Others' probability would be 10% from Model 2.</p>
<p>The final probabilities are:</p>
<ul>
<li>Packer 1: 10%</li>
<li>Packer 2: 20%</li>
<li>Packer 3: 60%</li>
<li>Packer 4: 30%</li>
<li>Others: 10%</li>
</ul>
<p>Packer 3 has the highest probability in this example, and the file is classified as such.</p>
<p>This simple combination approach ensures I maintain a suitable probability distribution while leveraging each model's strengths. The beauty of this method is not only its efficiency but also its scalability. I can introduce more models, each specializing in different packers, to further increase the classification capabilities.</p>
<p>Now you might wonder why I'd even write about this if the solution is this simple. The funny thing is I've explored multiple approaches to unifying the output. Before this, I fully implemented a complicated approach, only to later realize while writing this blog post that a much simpler approach works well enough for the tool's purpose.</p>
<h2 id="downsides">Downsides</h2>
<p>I am conscious that this may or may not be the most effective method to tackle this problem. But what is essential is that the current computation is simple and can maintain the appropriate prediction distribution based on the relative percentages. In essence, the category with the highest confidence score will always come out on top in the final output, primarily what users of my tool are interested in.</p>
<p>Aside from this, I am concerned that increasing the number of categories also increases training and prediction time. I'm not too worried about the increase in training time because this happens behind the scenes and remains unseen to users of my tool. I'm slightly concerned about the longer prediction time, as all models need to process each submission to the tool. And as I plan to incorporate more packer tool categories, the prediction time will definitely rise.</p>
<p>These downsides are not too much of a problem, however. They can easily be fixed if I find they are not meeting the tool's goals. For now, these will do.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I am genuinely happy with my progress with the VGL4NT Malware Packer Classifier. There are other topics I want to tackle, but I'll save those for future blog posts.</p>
<p>In the meantime, I invite you to check out the tool and see the changes yourself. Visit the <a href="https://packers.vgl4nt.com/">VGL4NT website</a> to get started. And for a more detailed walkthrough, you can also watch this <a href="https://www.youtube.com/watch?v=emIyy4Njw_g">YouTube video</a> I created</p>
        </div>

        <div class="tags">
            <a href="./tag/packers-malware-machine_learning-ml-update-vgl4nt.html" class="tag">packers malware machine_learning ml update vgl4nt</a>
        </div>
    </article>

<nav class="pagination">

        <span class="current">1</span>
        <a href="./index2.html">2</a>
        <a href="./index3.html">3</a>
        <a href="./index4.html">4</a>
        <a href="./index5.html">5</a>
        <a href="./index6.html">6</a>
        <a href="./index7.html">7</a>
        <a href="./index8.html">8</a>
        <a href="./index9.html">9</a>
        <a href="./index10.html">10</a>
        <a href="./index11.html">11</a>
        <a href="./index12.html">12</a>
        <a href="./index13.html">13</a>
        <a href="./index14.html">14</a>
        <a href="./index15.html">15</a>
        <a href="./index16.html">16</a>

    <a href="./index2.html">Next &raquo;</a>
</nav>
        </div>
    </main>

    <script src="./theme/js/main.js"></script>
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55068085-2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-55068085-2');
    </script>
</body>
</html>