<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>AccidentalRebel.com - re</title><link href="http://www.accidentalrebel.com/" rel="alternate"></link><link href="http://www.accidentalrebel.com/feeds/re.atom.xml" rel="self"></link><id>http://www.accidentalrebel.com/</id><updated>2021-09-29T10:34:00+08:00</updated><entry><title>IOLI Crackme 0x04</title><link href="http://www.accidentalrebel.com/ioli-crackme-0x04.html" rel="alternate"></link><published>2021-09-29T10:34:00+08:00</published><updated>2021-09-29T10:34:00+08:00</updated><author><name>AccidentalRebel</name></author><id>tag:www.accidentalrebel.com,2021-09-29:/ioli-crackme-0x04.html</id><content type="html">&lt;p&gt;I am continuing my reverse engineering review by tackling the &lt;em&gt;IOLI crackmes&lt;/em&gt; by &lt;a href="https://twitter.com/pof"&gt;@pof&lt;/a&gt;. These are beginner friendly challenges that is perfect for newbies or for those who want to review the basics like me. Check out my writeups for &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x00.html"&gt;0x00&lt;/a&gt;, &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x01.html"&gt;0x01&lt;/a&gt;, &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x02.html"&gt;0x02&lt;/a&gt;, and &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x03.html"&gt;0x03&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="getting-the-password"&gt;Getting the password&lt;/h1&gt;
&lt;p&gt;Loading the program in IDA revealed something new. There is now a &lt;code&gt;_check&lt;/code&gt; function that when opened looks more complicated than the previous challenges.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x04-01" src="http://www.accidentalrebel.com/images/ioli-crackme-0x04-01.png" /&gt;&lt;/p&gt;
&lt;p&gt;The one thing that I immediately noticed is the call to the &lt;code&gt;_strlen&lt;/code&gt; function similar to the previous challenge. This means that the length of the input string plays another important role.&lt;/p&gt;
&lt;p&gt;One curious thing is the condition that leads to the "Password Incorrect" block, as shown below.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x04-02" src="http://www.accidentalrebel.com/images/ioli-crackme-0x04-02.png" /&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;call&lt;/span&gt; &lt;span class="no"&gt;_strlen&lt;/span&gt;
&lt;span class="nf"&gt;cmp&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;ebp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;var_C&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="no"&gt;eax&lt;/span&gt;
&lt;span class="nf"&gt;jnb&lt;/span&gt; &lt;span class="no"&gt;short&lt;/span&gt; &lt;span class="no"&gt;loc_401387&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;From the looks of it, the check will fail if &lt;code&gt;var_C&lt;/code&gt; (Which is our &lt;code&gt;var_counter&lt;/code&gt; from the previous challenge) reaches the length of the entered string. If you think about it, this means that it doesn't matter how long the string that the user inputs. What's important is the content.&lt;/p&gt;
&lt;p&gt;To find out what the correct content the program expects, we need to look at the other block of code.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x04-03" src="http://www.accidentalrebel.com/images/ioli-crackme-0x04-03.png" /&gt;&lt;/p&gt;
&lt;p&gt;The code uses the same approach as the previous challenge where &lt;code&gt;var_counter&lt;/code&gt; is used to loop through individual characters in the input string.&lt;/p&gt;
&lt;p&gt;The part that is new is the use of the &lt;code&gt;_sscanf&lt;/code&gt; function which is defined as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"sscanf reads data from s and stores them according to parameter format into the locations given by the additional arguments, as if scanf was used, but reading from s instead of the standard input (stdin)."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Looking at how the function &lt;code&gt;_sscanf&lt;/code&gt; is used, it gets each character in the input string and converts them to decimal integers. This means that the password can only contain the numbers &lt;em&gt;0 through 9&lt;/em&gt;. The reason for this is because the result is added to another value at the line &lt;code&gt;add [eax], edx&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This &lt;em&gt;"other value"&lt;/em&gt; is the converted integer value from previous loops. This means that the algorithm adds each number from the input string after every loop. For example, an input string of &lt;code&gt;123&lt;/code&gt; translates to &lt;code&gt;1+2+3&lt;/code&gt; where the computed sum is saved to &lt;code&gt;var_8&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, there is the line &lt;code&gt;cmp [ebp+var_8], 0Fh&lt;/code&gt;, which tells us that the program expects the computed sum to be equal to &lt;code&gt;0Fh&lt;/code&gt; or &lt;code&gt;15&lt;/code&gt;. So as long as we enter numbers that would equal to &lt;code&gt;15&lt;/code&gt; when combined, then we are good.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x04-" src="http://www.accidentalrebel.com/images/ioli-crackme-0x04-.png" /&gt;&lt;/p&gt;
&lt;h1 id="patching-the-executables"&gt;Patching the executables&lt;/h1&gt;
&lt;p&gt;Patching the executable is different this time around. If on previous challenges we patched the program by changing an conditional opcode to a jmp (&lt;code&gt;74&lt;/code&gt; to &lt;code&gt;EB&lt;/code&gt;), for this one we only need to change the conditional to a &lt;code&gt;no op&lt;/code&gt; instruction (&lt;code&gt;00&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x04-05" src="http://www.accidentalrebel.com/images/ioli-crackme-0x04-05.png" /&gt;&lt;/p&gt;
&lt;p&gt;As you can see, the line &lt;code&gt;cmp [ebp+var_8]&lt;/code&gt; and the conditional branch disappears allowing us to go directly to the &lt;em&gt;"Password OK"&lt;/em&gt; part of the code.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x04-06" src="http://www.accidentalrebel.com/images/ioli-crackme-0x04-06.png" /&gt;&lt;/p&gt;
&lt;h1 id="on-to-the-next-challenge"&gt;On to the next challenge...&lt;/h1&gt;
&lt;p&gt;I liked this challenge mostly because it changed the passwords the program expects. The first time I tackled this challenge I used purely static analysis. I thought I got the answer only to realize that I was wrong by debugging the code. We have 5 more challenges to go!&lt;/p&gt;</content><category term="re"></category><category term="re"></category><category term="crackme"></category></entry><entry><title>IOLI Crackme 0x03</title><link href="http://www.accidentalrebel.com/ioli-crackme-0x03.html" rel="alternate"></link><published>2021-03-22T20:03:00+08:00</published><updated>2021-03-22T20:03:00+08:00</updated><author><name>AccidentalRebel</name></author><id>tag:www.accidentalrebel.com,2021-03-22:/ioli-crackme-0x03.html</id><content type="html">&lt;p&gt;I am continuing my reverse engineering review by tackling the &lt;em&gt;IOLI crackmes&lt;/em&gt; by &lt;a href="https://twitter.com/pof"&gt;@pof&lt;/a&gt;. These are beginner friendly challenges that is perfect for newbies or for those who want to review the basics like me. Check out my writeups for &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x00.html"&gt;0x00&lt;/a&gt;, &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x01.html"&gt;0x01&lt;/a&gt;, and &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x02.html"&gt;0x02&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="getting-the-password"&gt;Getting the password&lt;/h1&gt;
&lt;p&gt;After opening the program in IDA I immediately saw that the code is almost exactly as the one in challenge &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x02.html"&gt;0x02&lt;/a&gt;, with the exception of our expected &lt;code&gt;cmp&lt;/code&gt; command being inside the &lt;code&gt;_test&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x03-01" src="http://www.accidentalrebel.com/images/ioli-crackme-0x03-01.png" /&gt;&lt;/p&gt;
&lt;p&gt;Reading through the code I realized that the password for this challenge is exactly the same as the previous one!&lt;/p&gt;
&lt;p&gt;But what's this? The success and failure messages are all garbled? And plus, what is this other new function called &lt;code&gt;_shift&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x03-02" src="http://www.accidentalrebel.com/images/ioli-crackme-0x03-02.png" /&gt;&lt;/p&gt;
&lt;h1 id="a-different-kind-of-challenge"&gt;A different kind of challenge&lt;/h1&gt;
&lt;p&gt;Opening up the &lt;code&gt;_shift&lt;/code&gt; function shows us a short, but interesting looking program flow with two branches and one of the branches looping back. It seems we have a &lt;em&gt;loop&lt;/em&gt; here that we could investigate.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x03-03" src="http://www.accidentalrebel.com/images/ioli-crackme-0x03-03.png" /&gt;&lt;/p&gt;
&lt;p&gt;If we look at the input that the function takes we will find out that the strings that are being passed from the &lt;code&gt;_test&lt;/code&gt; function are &lt;code&gt;Lqydolg#Sdvvzrug$&lt;/code&gt; and &lt;code&gt;Sdvvzrug#RN$$$#=,&lt;/code&gt; for the &lt;em&gt;failure&lt;/em&gt; and &lt;em&gt;success&lt;/em&gt; messages, respectively. This tells us that a cipher is applied to these strings. What cipher it is using is what we'll be trying to find out.&lt;/p&gt;
&lt;h1 id="discovering-the-cipher"&gt;Discovering the cipher&lt;/h1&gt;
&lt;p&gt;The best way to discover the cipher used is to step through the code. We can do it with both static or dynamic analysis, but the latter is way easier.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x03-04" src="http://www.accidentalrebel.com/images/ioli-crackme-0x03-04.png" /&gt;&lt;/p&gt;
&lt;p&gt;The code above starts with &lt;code&gt;mov eax, [ebp+arg_0]&lt;/code&gt; which copies the pointer to the string passed to our &lt;code&gt;_shift&lt;/code&gt; function. We then copy that pointer to &lt;code&gt;[esp+98h+Str]&lt;/code&gt; which is the memory location pointing to the top of the current stack. This is done so that it can be passed as an argument when we do &lt;code&gt;call _strlen&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After executing, &lt;code&gt;_strlen&lt;/code&gt; returns the length of the specified string and is saved to register &lt;code&gt;eax&lt;/code&gt;. This is then used in the line &lt;code&gt;cmp [ebp+var_7C], eax&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;But what is the value of &lt;code&gt;var_7C&lt;/code&gt;? If you scroll up at the start of the subroutine, &lt;code&gt;var_7C&lt;/code&gt; is assigned a value of zero. If you know how loops work, you'll realize that this variable is going to be used to hold a counter value. It starts at a value of &lt;code&gt;0&lt;/code&gt; and it will eventually be incremented after every loop, which is what is happening at &lt;code&gt;401348&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To make it easy for us to remember this, let's rename &lt;code&gt;var_7C&lt;/code&gt; to a more memorable name like &lt;code&gt;var_counter&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x03-05" src="http://www.accidentalrebel.com/images/ioli-crackme-0x03-05.png" /&gt;&lt;/p&gt;
&lt;p&gt;So going back, to the comparison command &lt;code&gt;cmp [ebp+var_counter], eax&lt;/code&gt;, which now translates to &lt;code&gt;cmp 0, 17&lt;/code&gt;. &lt;em&gt;17&lt;/em&gt; being the length of our failure string &lt;code&gt;Lqydolg#Sdvvzrug$&lt;/code&gt;. Since this is not equal it now goes to this next block of code.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x03-06" src="http://www.accidentalrebel.com/images/ioli-crackme-0x03-06.png" /&gt;&lt;/p&gt;
&lt;p&gt;Now this block is interesting. There's a lot that is happening but the gist of it is that the program gets one character from the input string, with &lt;code&gt;var_counter&lt;/code&gt; as an offset. It then decrements that character value by 3, and added to a destination string. I'll be going through the code that I described step by step in the next section.&lt;/p&gt;
&lt;h1 id="stepping-through"&gt;Stepping through&lt;/h1&gt;
&lt;p&gt;So to start, &lt;code&gt;lea eax, [ebp+var_78]&lt;/code&gt; loads the address to &lt;code&gt;var_78&lt;/code&gt; which in my case points to the address &lt;code&gt;28FE90&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov edx, eax&lt;/code&gt; copies that address to &lt;code&gt;edx&lt;/code&gt; so we can use it on the next line.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;add edx, [ebp+var_counter]&lt;/code&gt; adds to the address of &lt;code&gt;var_78&lt;/code&gt;. Because &lt;code&gt;var_counter&lt;/code&gt; is still &lt;code&gt;0&lt;/code&gt;, the address remains at &lt;code&gt;28FE90&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;add eax, [ebp+arg_0]&lt;/code&gt; does the same thing as above but this time adding to &lt;code&gt;[arg_0]&lt;/code&gt; which contains the address &lt;code&gt;28FF10&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movzx eax, byte ptr [eax]&lt;/code&gt; copies the byte contained in &lt;code&gt;[eax]&lt;/code&gt; or &lt;code&gt;28FF10&lt;/code&gt;. In this case that byte contains the value &lt;code&gt;4Ch&lt;/code&gt; or &lt;code&gt;L&lt;/code&gt; in ASCII. This is the first letter in our failure string &lt;code&gt;Lqydolg#Sdvvzrug$&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sub al, 3&lt;/code&gt; then substracts 3 to &lt;code&gt;4Ch&lt;/code&gt; making it &lt;code&gt;49h&lt;/code&gt; which is ASCII for &lt;code&gt;I&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mov [edx], al&lt;/code&gt; saves the new character to the variable &lt;code&gt;var_78&lt;/code&gt; which is the memory location &lt;code&gt;28FE90&lt;/code&gt;. At this point in time the content is currently the character &lt;code&gt;I&lt;/code&gt;. To make it easy for us to understand the code, let's rename &lt;code&gt;var_78&lt;/code&gt; to &lt;code&gt;var_dest&lt;/code&gt;. This name is apt because this will be the destination for our shifted ASCII characters.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lea eax, [ebp+var_counter]&lt;/code&gt; and then &lt;code&gt;inc dword ptr [eax]&lt;/code&gt; now increments the value of &lt;code&gt;var_counter&lt;/code&gt;, which now makes it an integer value of &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id="looping-back"&gt;Looping back&lt;/h1&gt;
&lt;p&gt;Alright. Now we go back up again to &lt;code&gt;loc_401320&lt;/code&gt;. I'm not going to step through each line again, but I will highlight the important parts now that we have looped back.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cmp [ebp+var_counter]&lt;/code&gt; now translates to &lt;code&gt;cmp 1, 17&lt;/code&gt;, which is still not equal.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;add edx, [ebp+var_counter]&lt;/code&gt; now adds 1 to our &lt;code&gt;var_dest&lt;/code&gt; variable, turning &lt;code&gt;28FE90&lt;/code&gt; to &lt;code&gt;28FE91&lt;/code&gt;. The address for the &lt;code&gt;arg_0&lt;/code&gt; variable is also added by 1 at &lt;code&gt;add eax, [ebp+arg_0]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;By the time &lt;code&gt;movzx eax, byte ptr [eax]&lt;/code&gt; is executed it now gets the next character in our failure string which is &lt;code&gt;71h&lt;/code&gt; or the letter &lt;code&gt;q&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sub al, 3&lt;/code&gt; converts are letter &lt;code&gt;q&lt;/code&gt; to the letter &lt;code&gt;n&lt;/code&gt;. And is once again saved to our &lt;code&gt;var_dest&lt;/code&gt; variable with the command &lt;code&gt;mov [edx], al&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id="repeat-until"&gt;Repeat until...&lt;/h1&gt;
&lt;p&gt;If I haven't lost you, then you should now be able to follow what will happen in the next steps:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var_counter&lt;/code&gt; will get incremented again and again, which will point to the next characters in the string. For example, the next characters: &lt;code&gt;y&lt;/code&gt; then &lt;code&gt;d&lt;/code&gt; then &lt;code&gt;o&lt;/code&gt; will get shifted to &lt;code&gt;v&lt;/code&gt; then &lt;code&gt;a&lt;/code&gt; then &lt;code&gt;l&lt;/code&gt;, respectively. This shifting of each characters will continue until &lt;code&gt;cmp [ebp+var_counter&lt;/code&gt; equates to &lt;code&gt;cmp 17, 17&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;By the end, &lt;code&gt;var_dest&lt;/code&gt; now contains the newly shifted string &lt;code&gt;Invalid Password!&lt;/code&gt;. Finally! Applying the same code above to the success message, the garbled message would end with &lt;code&gt;Password OK!!! :)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Wasn't that fun?&lt;/p&gt;
&lt;h1 id="on-to-the-next-challenge"&gt;On to the next challenge&lt;/h1&gt;
&lt;p&gt;I hope I was able to explain properly the simple shifting algorithm used by the program above. I did it this way mostly for my own benefit and to make sure I really did understand how the algorithm worked in assembly. In future writeups I'll refrain from stepping through code at such a granular level, unless there is something really important that warrants it. Or maybe a video would be a much better format for these kinds of challenges?&lt;/p&gt;
&lt;p&gt;Anyway, I look forward to the next challenge. Hopefully, you are too!&lt;/p&gt;</content><category term="re"></category><category term="re"></category><category term="crackme"></category></entry><entry><title>IOLI Crackme 0x02</title><link href="http://www.accidentalrebel.com/ioli-crackme-0x02.html" rel="alternate"></link><published>2021-03-06T10:34:00+08:00</published><updated>2021-03-06T10:34:00+08:00</updated><author><name>AccidentalRebel</name></author><id>tag:www.accidentalrebel.com,2021-03-06:/ioli-crackme-0x02.html</id><content type="html">&lt;p&gt;I am continuing my reverse engineering review by tackling the &lt;em&gt;IOLI crackmes&lt;/em&gt; by &lt;a href="https://twitter.com/pof"&gt;@pof&lt;/a&gt;. These are beginner friendly challenges that is perfect for newbies or for those who want to review the basics like me. Check out my writeups for &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x00.html"&gt;0x00&lt;/a&gt; and &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x01.html"&gt;0x01&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="getting-the-password"&gt;Getting the password&lt;/h1&gt;
&lt;p&gt;After the first two challenges I kinda know what to expect already so I skipped running the program and immediately loaded it in IDA.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x02-01" src="http://www.accidentalrebel.com/images/ioli-crackme-0x02-01.png" /&gt;&lt;/p&gt;
&lt;p&gt;So the lines leading to the comparison command now looks more complicated than before. We could easily see that there are some computations that happens thanks to the presence of &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;imul&lt;/code&gt;. Before those, we have two values (&lt;code&gt;5Ah&lt;/code&gt; and &lt;code&gt;1ECh&lt;/code&gt;) which we can easily guess are the values that will be worked on by these arithmetic functions.&lt;/p&gt;
&lt;p&gt;So going through the lines sequentially we can see that the two numbers are first added with &lt;code&gt;add [eax], edx&lt;/code&gt;. Which results in a value of &lt;code&gt;246h&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After that we see the line &lt;code&gt;imul eax, [ebp+var_8]&lt;/code&gt;, which if you follow the sequence closely effectively multiplies &lt;code&gt;246h&lt;/code&gt; by itself, resulting in a value of &lt;code&gt;52B24h&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Convert &lt;code&gt;52B24h&lt;/code&gt; to decimal equates to &lt;code&gt;338724&lt;/code&gt;, which is unsprisingly the password that we need.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x02-02" src="http://www.accidentalrebel.com/images/ioli-crackme-0x02-02.png" /&gt;&lt;/p&gt;
&lt;h1 id="confirming-via-dynamic-analysis"&gt;Confirming via dynamic analysis&lt;/h1&gt;
&lt;p&gt;What we did above is that we used static analysis to inspect the program line by line to determine the final computed password value. Let's use dynamic analysis and step through the code to see how our data is manipulated in memory during this process.&lt;/p&gt;
&lt;p&gt;Let's set a breakpoint immediately after the initial two values are loaded into memory.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x02-03" src="http://www.accidentalrebel.com/images/ioli-crackme-0x02-03.png" /&gt;&lt;/p&gt;
&lt;p&gt;If we look at the memory locations we would see the following:&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x02-04" src="http://www.accidentalrebel.com/images/ioli-crackme-0x02-04.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;epb+var_8&lt;/code&gt; points to &lt;code&gt;28FF40&lt;/code&gt; which now contains &lt;code&gt;5Ah&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ebp+var_C&lt;/code&gt; points to &lt;code&gt;28FF3C&lt;/code&gt; which now contains &lt;code&gt;1ECh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Stepping through the code and checking the memory location after &lt;code&gt;add [eax], edx&lt;/code&gt; shows that the result &lt;code&gt;246h&lt;/code&gt; is saved at memory location &lt;code&gt;28FF40&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x02-05" src="http://www.accidentalrebel.com/images/ioli-crackme-0x02-05.png" /&gt;&lt;/p&gt;
&lt;p&gt;Then after &lt;code&gt;imul eax, [ebp+var_8]&lt;/code&gt; we see that eax now holds the value of &lt;code&gt;52B24h&lt;/code&gt;, confirming the final computed value that we had from our static analysis.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x02-06" src="http://www.accidentalrebel.com/images/ioli-crackme-0x02-06.png" /&gt;&lt;/p&gt;
&lt;h1 id="patching-the-executables"&gt;Patching the executables&lt;/h1&gt;
&lt;p&gt;Patching the executable is actually the same process as &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x00.html"&gt;my writeup for 0x00&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="on-to-the-next-challenge"&gt;On to the next challenge...&lt;/h1&gt;
&lt;p&gt;While the challenge is still easy, we can see that the complexity is slowly ramping up from previous challenges. We also took the time to confirm the result of our static analysis by debugging and stepping through the code. This is a good practice for me to familiarize myself with IDA, which I hope I could use in future challenges.&lt;/p&gt;</content><category term="re"></category><category term="re"></category><category term="crackme"></category></entry><entry><title>IOLI Crackme 0x01</title><link href="http://www.accidentalrebel.com/ioli-crackme-0x01.html" rel="alternate"></link><published>2021-02-20T17:34:00+08:00</published><updated>2021-02-20T17:34:00+08:00</updated><author><name>AccidentalRebel</name></author><id>tag:www.accidentalrebel.com,2021-02-20:/ioli-crackme-0x01.html</id><content type="html">&lt;p&gt;I am continuing my reverse engineering review by tackling the &lt;em&gt;IOLI crackmes&lt;/em&gt; by &lt;a href="https://twitter.com/pof"&gt;@pof&lt;/a&gt;. These are beginner friendly challenges that is perfect for newbies or for those who want to review the basics like me. Check out my writeup for 0x00 &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x00.html"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="getting-the-password"&gt;Getting the password&lt;/h1&gt;
&lt;p&gt;Of course, the first thing we do is run the program.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x01-01" src="http://www.accidentalrebel.com/images/ioli-crackme-0x01-01.png" /&gt;&lt;/p&gt;
&lt;p&gt;Just like last time, we opened up the program in IDA and focused on the part of the code that does the comparing of passwords.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x01-02" src="http://www.accidentalrebel.com/images/ioli-crackme-0x01-02.png" /&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;cmp&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;ebp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;var_4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;149&lt;/span&gt;&lt;span class="no"&gt;Ah&lt;/span&gt;
&lt;span class="nf"&gt;jz&lt;/span&gt; &lt;span class="no"&gt;short&lt;/span&gt; &lt;span class="no"&gt;loc_40137c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This seems easy enough. &lt;/p&gt;
&lt;p&gt;Initially I entered &lt;code&gt;149A&lt;/code&gt; as the password but this turned out to be incorrect. The reason for this is because &lt;code&gt;scanf&lt;/code&gt; was passed a format of &lt;em&gt;"%d"&lt;/em&gt;.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;esp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;Format&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="no"&gt;offset&lt;/span&gt; &lt;span class="no"&gt;aD&lt;/span&gt; &lt;span class="c1"&gt;; &amp;quot;%d&amp;quot;&lt;/span&gt;
&lt;span class="nf"&gt;call&lt;/span&gt; &lt;span class="no"&gt;_scanf&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This means that the input it expects is actually a decimal integer. So converting &lt;code&gt;149A&lt;/code&gt; to decimal results in &lt;code&gt;5274&lt;/code&gt;, which is the correct password.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x01-03" src="http://www.accidentalrebel.com/images/ioli-crackme-0x01-03.png" /&gt;&lt;/p&gt;
&lt;h1 id="patching-the-executables"&gt;Patching the executables&lt;/h1&gt;
&lt;p&gt;Patching the executable is actually the same process as &lt;a href="http://www.accidentalrebel.com/ioli-crackme-0x00.html"&gt;my writeup for 0x00&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="passing-arguments-to-functions"&gt;Passing arguments to functions&lt;/h1&gt;
&lt;p&gt;Since the crackme was cracked relatively quickly I want to review and highlight how arguments are passed to functions. &lt;/p&gt;
&lt;p&gt;The format of the &lt;code&gt;scanf&lt;/code&gt; function in C is like so:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;scanf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here's an example of how it is used:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;scanf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If we look at the 0x01 program we could see how the arguments are passed to the &lt;em&gt;_scanf&lt;/em&gt; function by placing the data to send on top of the stack.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;lea&lt;/span&gt; &lt;span class="no"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;ebp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;var_4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;esp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;var_14&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="no"&gt;eax&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;esp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;Format&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="no"&gt;offset&lt;/span&gt; &lt;span class="no"&gt;aD&lt;/span&gt;&lt;span class="c1"&gt;;  &amp;quot;%d&amp;quot;&lt;/span&gt;
&lt;span class="nf"&gt;call&lt;/span&gt; &lt;span class="no"&gt;_scanf&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;lea eax, [ebp+var_4]&lt;/code&gt; gets the address of &lt;em&gt;var_4&lt;/em&gt;, this is the memory location where scanf would put the inputted data. This is then added to the stack with &lt;code&gt;mov [esp+18h+var_14]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;offset aD&lt;/code&gt; gets the address of &lt;code&gt;aD&lt;/code&gt; which contains the string &lt;em&gt;"%d"&lt;/em&gt;. This is the &lt;em&gt;format&lt;/em&gt; parameter that &lt;em&gt;scanf&lt;/em&gt; expects. This is then added to the stack with &lt;code&gt;mov [esp+18h+Format]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With the two parameters added to the stack, it can now be used by the &lt;em&gt;scanf&lt;/em&gt; function when &lt;code&gt;call _scanf&lt;/code&gt; is executed.&lt;/p&gt;
&lt;p&gt;I'm not sure if I was able to explain that properly. At the very least, you should have been able to have a basic idea of how variables are passed to functions. Take note, however, that there are other calling conventions for functions which meants that the passing of arguments can also differ.&lt;/p&gt;
&lt;h1 id="on-to-the-next-challenge"&gt;On to the next challenge...&lt;/h1&gt;
&lt;p&gt;This is the second challenge out of 10 in the IOLI series of challenges. So far the challenges are still very easy, which is fine because it's still good for practice. I look forward to the next one.&lt;/p&gt;</content><category term="re"></category><category term="re"></category><category term="crackme"></category></entry><entry><title>IOLI Crackme 0x00</title><link href="http://www.accidentalrebel.com/ioli-crackme-0x00.html" rel="alternate"></link><published>2021-02-16T21:55:00+08:00</published><updated>2021-02-16T21:55:00+08:00</updated><author><name>AccidentalRebel</name></author><id>tag:www.accidentalrebel.com,2021-02-16:/ioli-crackme-0x00.html</id><content type="html">&lt;p&gt;I am re-familiarizing myself with reverse engineering again by going through some simple crackme challenges. This one is called the IOLI Crackmes by pof. The goal is to find the correct password and also to patch it so that it can accept any input and still show that it's correct.&lt;/p&gt;
&lt;h2 id="getting-the-password"&gt;Getting the password&lt;/h2&gt;
&lt;p&gt;Running the program shows a password prompt. &lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x00-03" src="http://www.accidentalrebel.com/images/ioli-crackme-0x00-03.png" /&gt;&lt;/p&gt;
&lt;p&gt;Of course, randomly entering passwords is going to be a waste of time so I opened up IDA to look at its code.&lt;/p&gt;
&lt;p&gt;I knew that whatever password I enter in the program would be checked against the actual password. This is the part of the program that I should focus on so I scanned the code and found this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x00-02" src="http://www.accidentalrebel.com/images/ioli-crackme-0x00-02.png" /&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;esp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;38&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;Str2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="no"&gt;offset&lt;/span&gt; &lt;span class="no"&gt;Str2&lt;/span&gt;&lt;span class="c1"&gt;; &amp;quot;250382&amp;quot;&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;esp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;38&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;Format&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="no"&gt;eax&lt;/span&gt;&lt;span class="c1"&gt;; &lt;/span&gt;
&lt;span class="nf"&gt;call&lt;/span&gt; &lt;span class="no"&gt;_strcmp&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And just from these few lines alone I already knew what the password is. IDA Pro was helpful enough to add a comment that &lt;code&gt;offset Str2&lt;/code&gt; equates to &lt;code&gt;250382&lt;/code&gt;. Surely enough, this number was the password.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x00-04" src="http://www.accidentalrebel.com/images/ioli-crackme-0x00-04.png" /&gt;&lt;/p&gt;
&lt;h2 id="patching-the-executable"&gt;Patching the executable&lt;/h2&gt;
&lt;p&gt;The next part of the challenge is to patch the executable so that it can accept any input and would still allow us through.&lt;/p&gt;
&lt;p&gt;Looking at the graph view, we want the program to always go to the node on the right which has the "Password OK" message. &lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x00-05" src="http://www.accidentalrebel.com/images/ioli-crackme-0x00-05.png" /&gt;&lt;/p&gt;
&lt;p&gt;The line that we could change to allow us to do this would be this one:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;jz&lt;/span&gt; &lt;span class="no"&gt;short&lt;/span&gt; &lt;span class="no"&gt;loc_40138A&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;jz&lt;/code&gt; can be changed to a &lt;code&gt;jmp&lt;/code&gt; command by changing the op code. Opening up the "Patch Bytes" window while the line is highlighted would show us this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x00-06" src="http://www.accidentalrebel.com/images/ioli-crackme-0x00-06.png" /&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;74&lt;/span&gt; &lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;C7&lt;/span&gt; &lt;span class="mf"&gt;04&lt;/span&gt; &lt;span class="mf"&gt;24&lt;/span&gt; &lt;span class="mf"&gt;2&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="mf"&gt;40&lt;/span&gt; &lt;span class="mf"&gt;40&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="n"&gt;E8&lt;/span&gt; &lt;span class="n"&gt;A8&lt;/span&gt; &lt;span class="mf"&gt;19&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="mf"&gt;00&lt;/span&gt; &lt;span class="n"&gt;EB&lt;/span&gt; &lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The opcode related to &lt;code&gt;jz short loc_40138A&lt;/code&gt; is the first two btyes &lt;code&gt;74 0E&lt;/code&gt;. &lt;code&gt;74&lt;/code&gt; is the "Jump short if equal" opcode and &lt;code&gt;0E&lt;/code&gt; is the relative jump distance. Changing &lt;code&gt;74&lt;/code&gt; to &lt;code&gt;EB&lt;/code&gt; converts it to the "Jump" opcode effectively making the line &lt;code&gt;jmp short loc_40138A&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x00-07" src="http://www.accidentalrebel.com/images/ioli-crackme-0x00-07.png" /&gt;&lt;/p&gt;
&lt;p&gt;After saving, IDA will automatically upgrade the graph. It will now show us that the flow of the program now jumps to the right node directly.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x00-08" src="http://www.accidentalrebel.com/images/ioli-crackme-0x00-08.png" /&gt;&lt;/p&gt;
&lt;p&gt;All that is left to do is to patch the executable via "Edit &amp;gt; Patch Program &amp;gt; Apply patches to input file..." and run the program. From here, any entered password would automatically get accepted.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ioli-crackme-0x00-09" src="http://www.accidentalrebel.com/images/ioli-crackme-0x00-09.png" /&gt;&lt;/p&gt;
&lt;h2 id="on-to-the-next-challenge"&gt;On to the next challenge...&lt;/h2&gt;
&lt;p&gt;This is the first out of the 10 challenges from this set. Since this is the first one, it is only natural for it to be very easy. It's still a good refresher for me especially since the last time I did any reversing was from a few years ago. I look forward to the next challenges, I do hope that they would ramp up in difficulty and also teach me new things for me to improve.&lt;/p&gt;</content><category term="re"></category><category term="re"></category><category term="crackme"></category></entry></feed>