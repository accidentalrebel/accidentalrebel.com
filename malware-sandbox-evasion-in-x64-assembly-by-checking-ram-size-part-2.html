<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Malware sandbox evasion in x64 assembly by checking ram size - Part 2</title>
  <meta name="author" content="AccidentalRebel">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta name="description" content="Malware sandbox evasion in x64 assembly by checking ram size - Part 2 August 15, 2022 in malware,sandbox,evasion,x64,assembly">

  <link rel="canonical" href="./malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2.html">

  <link href="./favicon.png" rel="icon">

  <link href="https://www.accidentalrebel.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="AccidentalRebel.com Full Atom Feed" />

  <link href="./theme/css/screen.css"  media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="./theme/css/tomorrow.css"  media="screen, projection" rel="stylesheet" type="text/css" />

  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.js"></script>
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

  
<meta name="twitter:card" content="summary">
<meta property="og:url" content="./malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2.html">
<meta name="twitter:site:id" content="https://twitter.com/accidentalrebel">
<meta name="twitter:creator:id" content="accidentalrebel">
<meta property="og:title" content="Malware sandbox evasion in x64 assembly by checking ram size - Part 2">
<meta property="og:description" content="In the previous post, I explored a sandbox evasion technique that uses GetPhysicallyInstalledSystemMem">
<meta property="og:image" content="https://www.accidentalrebel.com/images/malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2-01.png">
<meta name="twitter:image:src" content="https://www.accidentalrebel.com/images/malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2-01.png">


</head>
  <body>

    <div class="container" id="site-title">
      <div class="col-md-8 col-md-offset-2">
	<h1>
	  <a href=".">
	    AccidentalRebel.com
	  </a>
	</h1>
	<div id="profile">
	  <div class="left">
	    <img src="./theme/images/pic.png" />
	  </div>
	  <div class="right">
	    Karlo is a programmer for 10+ years who switched to cyber security. He is currently working as a L2 SOC Analyst and is focusing on malware reverse engineering and development.
	  </div>
	  <div class="clear"></div>
	</div>
	<div id="nav">
	  <ul>
	    <li><a href=".">Home</a></li>
	    <!-- <li><a href="./pages/made.html">My Works</a></li> -->
	    <li class="icon-nav" id="twitter-nav"><a href="https://twitter.com/accidentalrebel">Twitter</a></li>
	    <li class="icon-nav" id="github-nav"><a href="https://github.com/accidentalrebel">Github</a></li>
	    <li class="icon-nav" id="feed-nav"><a href="./feeds/all.atom.xml">RSS</a></li>
	  </ul>
	</div>
      </div>
    </div>

  <div class="container">
    <div class="row">
      <div class="col-md-8 col-md-offset-2">
	<article>
          <h1><a href="./malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2.html">Malware sandbox evasion in x64 assembly by checking ram size - Part 2</a></h1>
          <div class="meta">
            <time datetime="2022-08-15T11:29:00+08:00">August 15, 2022</time>
            in <span class="categories">
              <a href="./tag/malware.html">malware</a>,              <a href="./tag/sandbox.html">sandbox</a>,              <a href="./tag/evasion.html">evasion</a>,              <a href="./tag/x64.html">x64</a>,              <a href="./tag/assembly.html">assembly</a>            </span>
          </div>
        <p>In the <a href="./malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2.html">previous post</a>, I explored a sandbox evasion technique that uses <code>GetPhysicallyInstalledSystemMemory</code> to check the size of the RAM of the machine. The idea behind this technique (MBC Technique ID: <a href="https://github.com/MBCProject/mbc-markdown/blob/master/anti-behavioral-analysis/virtual-machine-detection.md">B0009.014</a>) is that any value that is lower than 4GB <em>may</em> probably be a sandbox (to reduce costs). This information can then be used with other sandbox evasion techniques to confirm.</p>
<p>For part 2 of this series, I'll be talking about an alternative Windows API function called <code>GlobalMemoryStatusEx</code>. This function is as straightforward as the first one, but requires the passing of a pointer to a C struct. This is significant because I'll be converting a working C code to x64 assembly so we can fully understand how it works under the hood.</p>
<h2 id="using-globalmemorystatusex">Using GlobalMemoryStatusEx</h2>
<p>Here is an example of an implementation of <code>GlobalMemoryStatusEx</code> in C that we'll later be converting to x64 assembly.</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MEMORYSTATUSEX</span><span class="w"> </span><span class="n">statex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">statex</span><span class="p">.</span><span class="n">dwLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">statex</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">GlobalMemoryStatusEx</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">statex</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Memory size: %*I64d&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">statex</span><span class="p">.</span><span class="n">ullTotalPhys</span><span class="o">/</span><span class="mi">1024</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>You will see that the first parameter for <code>GlobalMemoryStatusEx</code> is expecting a pointer to a <code>MEMORYSTATUSEX</code> object. We need to declare the memory location <code>statex</code> by putting it onto the stack. Before we can do that, however, we first need to know beforehand how much we would need to reserve.</p>
<h2 id="getting-the-size-of-the-struct">Getting the size of the struct</h2>
<p>Finding out the size of a structure in C is easy with the <code>sizeof</code> function. However, we can't really use this in assembly, so we have to determine it manually by adding up the sizes of each member of the struct.</p>
<p>Consider the example struct definition below:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">TestStruct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">member1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">member2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">member3</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>

<p>If we would look at <a href="https://docs.microsoft.com/en-us/cpp/cpp/fundamental-types-cpp?view=msvc-170#sizes-of-built-in-types">this table</a> containing the fundamental types and their sizes, we could determine the sizes of each member:</p>
<ul>
<li><code>member1</code> is of type <code>char</code> which has a size of <em>1 byte</em></li>
<li><code>member2</code> is of type <code>int</code> which is <em>4 bytes</em></li>
<li><code>member3</code> is of type <code>float</code> which also is <em>4 bytes</em></li>
</ul>
<p>Adding all of these sizes results in <code>TestStruct</code> having a total size of <em>9 bytes</em>.</p>
<p>Now to apply the same computation to our <code>MEMORYSTATUSEX</code> struct. Here is the definition of the struct <a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/ns-sysinfoapi-memorystatusex">according to MSDN</a>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_MEMORYSTATUSEX</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">DWORD</span><span class="w">     </span><span class="n">dwLength</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">DWORD</span><span class="w">     </span><span class="n">dwMemoryLoad</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">DWORDLONG</span><span class="w"> </span><span class="n">ullTotalPhys</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">DWORDLONG</span><span class="w"> </span><span class="n">ullAvailPhys</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">DWORDLONG</span><span class="w"> </span><span class="n">ullTotalPageFile</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">DWORDLONG</span><span class="w"> </span><span class="n">ullAvailPageFile</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">DWORDLONG</span><span class="w"> </span><span class="n">ullTotalVirtual</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">DWORDLONG</span><span class="w"> </span><span class="n">ullAvailVirtual</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">DWORDLONG</span><span class="w"> </span><span class="n">ullAvailExtendedVirtual</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">MEMORYSTATUSEX</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">LPMEMORYSTATUSEX</span><span class="p">;</span><span class="w"></span>
</code></pre></div>

<p>The types that we have are <code>DWORD</code> and <code>DWORDLONG</code> (which is just <a href="https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types?redirectedfrom=MSDN">Window's own version</a> of <code>unsigned long</code> and <code>unsigned int64</code>):</p>
<ul>
<li><code>DWORD</code> or <code>unsigned long</code> has a size of <em>4 bytes</em></li>
<li><code>DWORDLONG</code> or <code>unsigned int64</code> has a size of <em>8 bytes</em></li>
</ul>
<p>So adding the two <code>DWORD</code>s and seven <code>DWORDLONG</code>s results in <code>MEMORYSTATUSEX</code> having a total size of <em>64 bytes</em>.</p>
<h2 id="initializing-statex">Initializing statex</h2>
<p>Now that we know the total size, we can now reserve this amount of space on the stack.</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="nf">sub</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">0x40</span><span class="w">   </span><span class="c1">; Reserve space for struct on stack</span>
<span class="w">                    </span><span class="c1">; MEMORYSTATUSEX&#39;s is 64 bytes (0x40) in size</span>
</code></pre></div>

<p>Before we can call <code>GlobalMemoryStatusEx</code>, however, <a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/ns-sysinfoapi-memorystatusex">MSDN states</a> that the <code>dwLength</code> member should be first set. And this can be done by assigning <em>64 bytes</em> to the corresponding memory location on the stack.</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x40</span><span class="w">   </span>
<span class="w">    </span><span class="no">mov</span><span class="w"> </span><span class="p">[</span><span class="no">rsp</span><span class="p">],</span><span class="w"> </span><span class="no">rax</span><span class="w">  </span><span class="c1">; Assign 0x40 to dwLength</span>
<span class="w">    </span><span class="nf">lea</span><span class="w"> </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rsp</span><span class="p">]</span><span class="w">  </span><span class="c1">; Load the memory location of struct</span>
</code></pre></div>

<p>With this we can finally call our function:</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="nf">sub</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w">     </span><span class="c1">; Reserve shadow space</span>
<span class="w">    </span><span class="nf">call</span><span class="w">    </span><span class="no">GlobalMemoryStatusEx</span><span class="w"></span>
<span class="w">    </span><span class="nf">add</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w">     </span><span class="c1">; Release shadow space</span>
</code></pre></div>

<h2 id="using-the-result">Using the result</h2>
<p>If successful, the function <code>GlobalMemoryStatusEx</code> populates the memory location we passed to it, as shown below:</p>
<p><img alt="malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2-01" src="./images/malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2-01.png" /></p>
<p>The struct member <code>ullTotalPhys</code> now has the memory size that we need. And because our stack pointer still points to the beginning of the struct, we can get this value by adding an offset to <code>rsp</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rsp</span><span class="err">+</span><span class="mi">0x8</span><span class="p">]</span><span class="w">  </span><span class="c1">; Retrive value of ullTotalPhys from stack</span>
</code></pre></div>

<p>We offset by <code>0x8</code> because the first 8 bytes is assigned to <code>dwLength</code> and <code>dwMemoryLoad</code> (both at 4 bytes each).</p>
<h2 id="displaying-the-result">Displaying the result</h2>
<p>As seen above, the value returned by <code>GlobalMemoryStatusEx</code> is in bytes. To be consistent with our example from the previous post, we need to convert this value to kilobytes by dividing it by <code>1024</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"></span>
<span class="w">    </span><span class="nf">xor</span><span class="w"> </span><span class="no">rdx</span><span class="p">,</span><span class="w"> </span><span class="no">rdx</span><span class="w">    </span><span class="c1">; Clear rdx; This is required before calling div</span>
<span class="w">    </span><span class="nf">div</span><span class="w"> </span><span class="no">rcx</span><span class="w">         </span><span class="c1">; Divide by 1024 to convert to KB</span>
</code></pre></div>

<p>The result of the above operation is saved to <code>rax</code> which we can then move to <code>rdx</code> so we can pass it as the second argument to <code>printf</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">rdx</span><span class="p">,</span><span class="w"> </span><span class="no">rax</span><span class="w">    </span><span class="c1">; Argument 2; Result of ullTotalPhys / 1024</span>
<span class="w">    </span><span class="nf">lea</span><span class="w"> </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">msg_memory_size</span><span class="p">]</span><span class="w">  </span><span class="c1">; Argument 1; Format string</span>
<span class="w">    </span><span class="nf">sub</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w">     </span><span class="c1">; Reserve shadow space</span>
<span class="w">    </span><span class="nf">call</span><span class="w">    </span><span class="no">printf</span><span class="w"></span>
<span class="w">    </span><span class="nf">add</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w">     </span><span class="c1">; Release shadow space</span>
</code></pre></div>

<p>With this, we can now finally display the result on the console:</p>
<p><img alt="malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2-02" src="./images/malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2-02.png" /></p>
<p>Here is the full source code for reference:</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="nf">bits</span><span class="w"> </span><span class="mi">64</span><span class="w"></span>
<span class="w">    </span><span class="nf">default</span><span class="w"> </span><span class="no">rel</span><span class="w"></span>

<span class="nf">segment</span><span class="w"> </span><span class="no">.data</span><span class="w"></span>
<span class="w">    </span><span class="nf">msg_memory_size</span><span class="w"> </span><span class="no">db</span><span class="w">  </span><span class="err">&quot;</span><span class="no">Memory</span><span class="w"> </span><span class="no">size</span><span class="p">:</span><span class="w"> </span><span class="nv">%lld</span><span class="err">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0xd</span><span class="p">,</span><span class="w"> </span><span class="mi">0xa</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="nf">segment</span><span class="w"> </span><span class="no">.text</span><span class="w"></span>
<span class="w">    </span><span class="nf">global</span><span class="w"> </span><span class="no">main</span><span class="w"></span>
<span class="w">    </span><span class="nf">extern</span><span class="w"> </span><span class="no">ExitProcess</span><span class="w"></span>
<span class="w">    </span><span class="nf">extern</span><span class="w"> </span><span class="no">GlobalMemoryStatusEx</span><span class="w"></span>
<span class="w">    </span><span class="nf">extern</span><span class="w"> </span><span class="no">printf</span><span class="w"></span>

<span class="nl">main:</span><span class="w"></span>
<span class="w">    </span><span class="nf">push</span><span class="w">    </span><span class="no">rbp</span><span class="w"></span>
<span class="w">    </span><span class="nf">mov</span><span class="w">     </span><span class="no">rbp</span><span class="p">,</span><span class="w"> </span><span class="no">rsp</span><span class="w"></span>

<span class="w">    </span><span class="nf">sub</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">0x40</span><span class="w">   </span><span class="c1">; Reserve space for struct on stack</span>
<span class="w">                    </span><span class="c1">; MEMORYSTATUSEX&#39;s is 64 bytes (0x40) in size </span>

<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="mi">0x40</span><span class="w">   </span>
<span class="w">    </span><span class="no">mov</span><span class="w"> </span><span class="p">[</span><span class="no">rsp</span><span class="p">],</span><span class="w"> </span><span class="no">rax</span><span class="w">  </span><span class="c1">; Assign 0x40 to dwLength</span>
<span class="w">    </span><span class="nf">lea</span><span class="w"> </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rsp</span><span class="p">]</span><span class="w">  </span><span class="c1">; Load the memory location of struct</span>

<span class="w">    </span><span class="nf">sub</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w">     </span><span class="c1">; Reserve shadow space</span>
<span class="w">    </span><span class="nf">call</span><span class="w">    </span><span class="no">GlobalMemoryStatusEx</span><span class="w"></span>
<span class="w">    </span><span class="nf">add</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w">     </span><span class="c1">; Release shadow space</span>

<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rsp</span><span class="err">+</span><span class="mi">0x8</span><span class="p">]</span><span class="w">  </span><span class="c1">; Retrive value of ullTotalPhys from stack</span>
<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"></span>
<span class="w">    </span><span class="nf">xor</span><span class="w">     </span><span class="no">rdx</span><span class="p">,</span><span class="w"> </span><span class="no">rdx</span><span class="w">    </span><span class="c1">; Clear rdx; This is required before calling div</span>
<span class="w">    </span><span class="nf">div</span><span class="w"> </span><span class="no">rcx</span><span class="w">     </span><span class="c1">; Divide by 1024 to convert to KB</span>

<span class="w">    </span><span class="nf">mov</span><span class="w"> </span><span class="no">rdx</span><span class="p">,</span><span class="w"> </span><span class="no">rax</span><span class="w">    </span><span class="c1">; Argument 2; Result of ullTotalPhys / 1024</span>
<span class="w">    </span><span class="nf">lea</span><span class="w"> </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">msg_memory_size</span><span class="p">]</span><span class="w">  </span><span class="c1">; Argument 1; Format string</span>
<span class="w">    </span><span class="nf">sub</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w">     </span><span class="c1">; Reserve shadow space</span>
<span class="w">    </span><span class="nf">call</span><span class="w">    </span><span class="no">printf</span><span class="w"></span>
<span class="w">    </span><span class="nf">add</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w">     </span><span class="c1">; Release shadow space</span>

<span class="w">    </span><span class="nf">add</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">0x40</span><span class="w">   </span><span class="c1">; Release space of struct from stack</span>

<span class="w">    </span><span class="nf">xor</span><span class="w">     </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rax</span><span class="w"></span>
<span class="w">    </span><span class="nf">call</span><span class="w">    </span><span class="no">ExitProcess</span><span class="w"></span>
</code></pre></div>

<h2 id="conclusion">Conclusion</h2>
<p>Over the past two blog posts, we've learned how to use <code>GlobalMemoryStatusEx</code> and <code>GetPhysicallyInstalledSystemMemory</code> to determine the size of the RAM of a machine. We've also learned about using the stack to pass arguments to functions using x64 assembly.</p>
<p>In future posts I plan to continue exploring malware behavior and techniques and at the same time teach x64 assembly so that we can both improve when writing and reverse engineering malware.</p>
<p>Until then, you can view the C and Assembly code along with the build scripts for this evasion technique on this repository <a href="https://github.com/accidentalrebel/sandbox-evasion-by-checking-ram-size">here</a>.</p>
<p>Feel free to reach out to me on <a href="https://twitter.com/accidentalrebel">Twitter</a> or <a href="https://www.linkedin.com/in/juan-karlo-licudine/">LinkedIn</a> for any questions or comments.</p>
        <!-- Disqus goes here -->
        <section>
          <h1>Comments</h1>
          <div id="disqus_thread" aria-live="polite">Disqus goes here</div>
	  <script>
	    /**
	     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
	     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
	    /*
	     var disqus_config = function () {
	     this.page.url = AccidentalRebel;  // Replace PAGE_URL with your page's canonical URL variable
	     this.page.identifier = malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2.html; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
	     };
	    */
	    (function() { // DON'T EDIT BELOW THIS LINE
		var d = document, s = d.createElement('script');
		s.src = 'https://accidentalrebel.disqus.com//embed.js';
		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
	    })();
	  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        </section>
	</article>
      </div>
    </div>
  </div>
    <footer id="footer" class="her-row">
      <div class="container">
        <div class="row">
          <h4>Powered by <a href="http://blog.getpelican.com/">Pelican</a>. Designed by <a href="http://AdrianArtiles.com">Adrian Artiles</a>.</h4>
        </div>
      </div>
    </footer>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55068085-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-55068085-2');
    </script>
  </body>
</html>